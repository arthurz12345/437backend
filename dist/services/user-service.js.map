{
  "version": 3,
  "sources": ["../../src/services/user-service.ts"],
  "sourcesContent": ["import { Document } from \"mongoose\";\nimport { User } from \"./../models/user\";\nimport UserSchemaModel from \"./../models/mongo/user-schema-model\";\nimport jwt, { Secret, JwtPayload } from 'jsonwebtoken';\nimport bcrypt from \"bcryptjs\";\nimport { Request, Response, NextFunction } from 'express';\n\nexport function index(): Promise<User[]> {\n    return UserSchemaModel.find();\n}\n\nexport function get(username: String): Promise<User> {\n    return UserSchemaModel.find({ username })\n    .then((list) => list[0])\n    .catch((err) => {\n        throw `${username} Not Found`;\n    });\n}\n\nexport function getAllUsers(): Promise<User[]> {\n  return UserSchemaModel.find({})\n  .then((list) => list)\n  .catch((err) => {\n      throw `error get all users - ${err} `;\n  });\n}\n\nexport function create(user: User): Promise<User> {\n    const p = new UserSchemaModel(user);\n    return p.save();\n}\n\n\nexport function createUser(newUser: User) {\n  return new Promise<User>((resolve, reject) => {\n    if (!newUser.username || !newUser.password) {\n      reject(\"must provide username and password\");\n    }\n    UserSchemaModel\n      .find({ username: newUser.username })\n      .then((found: User[]) => {\n        if (found && found.length >= 1)\n            reject(\"username exists\");\n          else return true;\n      })\n      .then((usernameUnique) =>{\n        if (usernameUnique){ \n          bcrypt\n            .genSalt(10)\n            .then((salt: string) => bcrypt.hash(newUser.password, salt))\n            .then((hashedPassword: string) => {\n              const user = new UserSchemaModel({\n                username:newUser.username,\n                password: hashedPassword,\n                firstName:newUser.firstName,\n                lastName: newUser.lastName,\n                role: newUser.role ?? \"member\"\n              });\n              user.save().then((createdNewUser: User) => {\n                if (createdNewUser) resolve(createdNewUser);\n              });\n            })\n        }\n        }\n      );\n  });\n}\n\nexport function update(username: String, user: User): Promise<User> {\n    return new Promise((resolve, reject) => {\n        UserSchemaModel.findOneAndUpdate({ username }, user, {\n            new: true,\n    }).then((user) => {\n        if (user) resolve(user);\n        else reject(\"Failed to update user profile\");\n    });\n    });\n}\n\nexport function loginUser(username: string, password: string) {\n  return new Promise((resolve, reject) => {\n    if (!username || !password) {\n      reject(\"must provide username and password\");\n    } else {\n      verify(username, password)\n        .then((goodUser: String) => generateAccessToken(goodUser))\n        .then((token) =>{\n          if(token) resolve(token)\n        })\n        .catch((error) => reject(\"Unauthorized\"));\n    }\n  })\n}\n\nexport function verify(\n  username: string,\n  password: string\n): Promise<String> {\n  return new Promise<String>((resolve, reject) => {\n    UserSchemaModel\n      .find({ username })\n      .then((found) => {\n        console.log(found)\n        if (found && found.length >= 1) return found[0];\n        else reject(\"Invalid username or password\");\n      })\n      .then((userOnFile) => {\n\n        if(userOnFile){\n          bcrypt.compare(password, userOnFile.password, (err, data) => {\n            //if error than throw error\n            if (err) throw err\n            console.log(data);\n            //if both match than you can do anything\n            if (data) {\n              resolve(userOnFile.username);\n                //return res.status(200).json({ msg: \"Login success\" })\n            } else {\n                reject(\"Invalid username or password\");\n                //return res.status(401).json({ msg: \"Invalid credencial\" })\n            }\n          })\n        }\n        else reject(\"Invalid username or password\");\n        \n      });\n  });\n}\n\nexport function checkExists(username: string) {\n  return new Promise<boolean>((resolve, reject) => {\n    UserSchemaModel\n      .find({ username })\n      .then((found) => resolve(found && found.length > 0));\n  });\n}\n\nexport function generateAccessToken(username: String) {\n    console.log(\"Generating token for\", username);\n    \n    return new Promise((resolve, reject) => {\n    jwt.sign({ username: username }, process.env.JWT_SECRET as string, \n      { expiresIn: '1h'}, \n      (err, encodedToken)=>{\n          err ? reject(err) : resolve(encodedToken)\n      })\n    })\n  };\n\n//const getUsernameFromToken = (token) => jwt.decode(token)[\"username\"];\n\n//exports.getAudienceFromToken = (token) => jwt.decode(token)[\"aud\"];\n  \nexport default { index, get, getAllUsers, create, update, generateAccessToken, createUser, loginUser, verify }"],
  "mappings": "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",
  "names": ["UserSchemaModel", "bcrypt", "user", "jwt"]
}
